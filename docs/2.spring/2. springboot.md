# 1. SpringBoot

## 1.1. 什么是 Spring Boot？

Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。

## 1.2. Spring 的缺点

使用了大量的反射机制，反射机制非常占用内存。

## 1.3. 为什么要用 SpringBoot

快速开发，快速整合，配置简化、内嵌服务容器

## 1.4. 说出使用 Spring Boot 的主要优点

- 独立运行
- 简化配置
- 自动配置
- 无代码生成和 XML 配置
- 应用监控
- 上手容易

## 1.5. 什么是 Spring Boot Starters?

Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。
Starters 包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。

## 1.6. Spring Boot 支持哪些内嵌 Servlet 容器？

Spring Boot 支持 Tomcat、Jetty 和 Undertow 三种 Servlet 容器嵌入到 Web 应用程序中，开发者使用 starter 即可方便嵌入，默认情况下，嵌入服务器的访问端口为 8080。

## 1.7. 介绍一下@SpringBootApplication 注解

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

@ComponentScan：Spring 组件扫描。

## 1.8. Spring Boot 的自动配置是如何实现的?

Spring Boot 启动的时候会通过@EnableAutoConfiguration 注解找到 META-INF/spring.factories 配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以 AutoConfiguration 结尾来命名的，它实际上就是一个 JavaConfig 形式的 Spring 容器配置类，它能通过以 Properties 结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而 XxxxProperties 类是通过@ConfigurationProperties 注解与全局配置文件中对应的属性进行绑定的。

## 1.9. 常用的注解有哪些？

1、@SpringBootApplication

这个注解是 Spring Boot 最核心的注解，用在 Spring Boot 的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan 三个注解的组合。由于这些注解一般都是一起使用，所以 Spring Boot 提供了一个统一的注解@SpringBootApplication。

2、@EnableAutoConfiguration

允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。

如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。

@EnableAutoConfiguration 实现的关键在于引入了 AutoConfigurationImportSelector，其核心逻辑为 selectImports 方法，逻辑大致如下：

● 　从配置文件 META-INF/spring.factories 加载所有可能用到的自动配置类；

● 　去重，并将 exclude 和 excludeName 属性携带的类排除；

● 　过滤，将满足条件（@Conditional）的自动配置类返回；

3、@Configuration

用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的 xml 配置文件，一般加在主类上。如果有些第三方库需要用到 xml 文件，建议仍然通过@Configuration 类作为项目的配置主类——可以使用@ImportResource 注解加载 xml 配置文件。

4、@ComponentScan

组件扫描。让 spring Boot 扫描到 Configuration 类并把它加入到程序上下文。

@ComponentScan 注解默认就会装配标识了@Controller，@Service，@Repository，@Component 注解的类到 spring 容器中。

5、@Repository

用于标注数据访问组件，即 DAO 组件。

使用@Repository 注解可以确保 DAO 或者 repositories 提供异常转译，这个注解修饰的 DAO 或者 repositories 类会被 ComponetScan 发现并配置，同时也不需要为它们提供 XML 配置项。

6、@Service

一般用于修饰 service 层的组件

7、@RestController

用于标注控制层组件(如 struts 中的 action)，表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器；它是@Controller 和@ResponseBody 的合集。

8、@ResponseBody

表示该方法的返回结果直接写入 HTTP response body 中

一般在异步获取数据时使用，在使用@RequestMapping 后，返回值通常解析为跳转路径，加上@responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。比如异步获取 json 数据，加上@responsebody 后，会直接返回 json 数据。

9、@Component

泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

10、@Bean

相当于 XML 中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个 bean,并交给 spring 管理。

11、@AutoWired

byType 方式。把配置好的 Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。

当加上（required=false）时，就算找不到 bean 也不报错。

12、@Qualifier

当有多个同一类型的 Bean 时，可以用@Qualifier("name")来指定。与@Autowired 配合使用

13、@Resource(name="name",type="type")

没有括号内内容的话，默认 byName。与@Autowired 干类似的事。

14、@RequestMapping

RequestMapping 是一个用来处理请求地址映射的注解；提供路由信息，负责 URL 到 Controller 中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

15、@RequestParam

用在方法的参数前面。例：

@RequestParam String a =request.getParameter("a")
路径变量。参数与大括号里的名字一样要相同。例：16、@PathVariable

复制代码
RequestMapping("user/get/mac/{macAddress}")

public String getByMacAddress(@PathVariable String macAddress){

//do something;

}
复制代码
Spring Profiles 提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。17、@Profiles

任何@Component 或@Configuration 都能被@Profile 标记，从而限制加载它的时机。

复制代码
@Configuration

@Profile("prod")

public class ProductionConfiguration {

    // ...

}
复制代码
Spring Boot 可使用注解的方式将自定义的 properties 文件映射到实体 bean 中，比如 config.properties 文件。

18、@ConfigurationProperties

复制代码
@Data

@ConfigurationProperties("rocketmq.consumer")

public class RocketMQConsumerProperties extends RocketMQProperties {

    private boolean enabled = true;

    private String consumerGroup;

    private MessageModel messageModel = MessageModel.CLUSTERING;

    private ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;

    private int consumeThreadMin = 20;

    private int consumeThreadMax = 64;

    private int consumeConcurrentlyMaxSpan = 2000;

    private int pullThresholdForQueue = 1000;

    private int pullInterval = 0;

    private int consumeMessageBatchMaxSize = 1;

    private int pullBatchSize = 32;

}

## 1.10. Spring Boot 的配置文件有哪几种格式？它们有什么区别？

.properties 和 .yml，它们的区别主要是书写格式不同。

```properties
app.user.name = javastack
```

```yml
app:
  user:
    name: javastack
```

另外，.yml 格式不支持 @PropertySource 注解导入配置。

## 1.11. 什么是 YAML？YAML 配置的优势在哪里 ?

### 1.11.1. 优点:

1. 配置有序，在一些特殊的场景下，配置有序很重要。
1. 支持数组，数组中的元素可以是基本数据类型和对象
1. 简洁。

### 1.11.2. 缺点：

不支持 @PropertySource 注解导入自定义的 YAML 配置。

## 1.12. Spring Boot 常用的读取配置文件的方法有哪些？

### 1.12.1. @Value

基本类型属性注入，直接在字段上添加@Value("${xxx.xxx}")即可

```yml
user:
  name: Manaphy
  age: 19
  sex: male
```

```java
@RestController
public class ConfigPropertiesController {
    @Value("${user.name}")
    private String name;
    @Value("${user.age}")
    private Integer age;
    @Value("${user.sex}")
    private String sex;

    @GetMapping("/user")
    public String getUser() {
        return "{name:" + name + ",age:" + age + ",sex:" + sex + "}";
    }
}
```

### 1.12.2. @ConfigurationProperties

```yml
# 配置文件
person:
  lastName: hello
  age: 18
  boss: false
  birth: 2017/12/12
  maps: { k1: v1, k2: v2 }
  lists:
    - lisi
    - wangwu
  dog:
    name: 小狗
    age: 12
```

```java
// JavaBean

/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定;
 * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能
 */
@Component
@ConfigurationProperties(prefix = "person")
@Data
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String, Object> maps;
    private List<Object> lists;
    private Dog dog;

}
```

### 1.12.3. @PropertySource

```yml
<!-- 配置文件 -->

person.lastName=chen
person.age=22
person.boss=false
person.birth=2017/12/12
person.map1.k1=v1
person.map1.k2=v2
person.map2[k1]=v1
person.map2[k2]=v2
person.list[0]=zhang
person.list[1]=wang
person.list2=zhao,qian,sun,li
person.dog.name=小狗
person.dog.age=12
```

```java

// JavaBean

@Component
@ConfigurationProperties(prefix = "person")
//如果只有一个主配置类文件，@PropertySource可以不写
@PropertySource("classpath:person.properties")
@Data
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String, Object> map1;
    private Map<String, Object> map2;
    private List<Object> list;
    private List<Object> list2;
    private Dog dog;

}

@Data
class Dog {
    private String name;
    private Integer age;
}
```

### 1.12.4. 使用工具类 无需注入获取.yml 中的值

```java
// 新建 BeanConfiguration 类，用于项目启动构造我们的工具类
@Configuration
@Slf4j
public class BeanConfiguration {

    @Bean
    public YamlConfigurerUtil ymlConfigurerUtil() {
        //1:加载配置文件
        Resource app = new ClassPathResource("application.yml");
        Resource appDev = new ClassPathResource("application-dev.yml");
        Resource appProd = new ClassPathResource("application-prod.yml");
        YamlPropertiesFactoryBean yamlPropertiesFactoryBean = new YamlPropertiesFactoryBean();
        // 2:将加载的配置文件交给 YamlPropertiesFactoryBean
        yamlPropertiesFactoryBean.setResources(app);
        // 3：将yml转换成 key：val
        Properties properties = yamlPropertiesFactoryBean.getObject();
        String active = null;
        if (properties != null) {
            active = properties.getProperty("spring.profiles.active");
        }
        if (StringUtils.isEmpty(active)) {
            log.error("未找到spring.profiles.active配置！");
        } else {
            //判断当前配置是什么环境
            if ("dev".equals(active)) {
                yamlPropertiesFactoryBean.setResources(app, appDev);
            } else if ("prod".equals(active)) {
                yamlPropertiesFactoryBean.setResources(app, appProd);
            }
        }
        // 4: 将Properties 通过构造方法交给我们写的工具类
        return new YamlConfigurerUtil(yamlPropertiesFactoryBean.getObject());
    }
}

// 工具类实现
public class YamlConfigurerUtil {
    private static Properties ymlProperties = new Properties();

    public YamlConfigurerUtil(Properties properties) {
        ymlProperties = properties;
    }

    public static String getStrYmlVal(String key) {
        return ymlProperties.getProperty(key);
    }

    public static Integer getIntegerYmlVal(String key) {
        return Integer.valueOf(ymlProperties.getProperty(key));
    }
}
```

## 1.13. Spring Boot 加载配置文件的优先级？

对于 springboot 项目而言，默认的配置文件都是放在 resources 的文件目录下的

### 1.13.1. 加载规则：

1. 优先级 no1：与 src 级别相同的并且是 config 下的配置文件
1. 优先级 no2：与 src 级别相同的并且之下的配置文件
1. 优先级 no3：resources 下如果有 config 文件夹，里面的配置文件优先加载
1. 优先级 no4：resources 默认的配置文件后加载

【备注】：如果目录级别相同，则 config 文件夹下的先加载，高优先的文件覆盖低优先级的配置

## 1.14. 常用的 Bean 映射工具有哪些？

常用的有 apache 的 BeanUtils，spring 的 BeanUtils，cglib 的 BeanCopier。

### 1.14.1. BeanUtils

apache 的 BeanUtils 和 spring 的 BeanUtils 中拷贝方法的原理都是先用 jdk 中 java.beans.Introspector 类的 getBeanInfo()方法获取对象的属性信息及属性 get/set 方法，接着使用反射（Method 的 invoke(Object obj, Object... args)）方法进行赋值。apache 支持名称相同但类型不同的属性的转换，spring 支持忽略某些属性不进行映射，他们都设置了缓存保存已解析过的 BeanInfo 信息。

### 1.14.2. BeanCopier

cglib 的 BeanCopier 采用了不同的方法：它不是利用反射对属性进行赋值，而是直接使用 ASM 的 MethodVisitor 直接编写各属性的 get/set 方法（具体过程可见 BeanCopier 类的 generateClass(ClassVisitor v)方法）生成 class 文件，然后进行执行。由于是直接生成字节码执行，所以 BeanCopier 的性能较采用反射的 BeanUtils 有较大提高，这一点可在后面的测试中看出。

## 1.15. Spring Boot 如何监控系统实际运行状况？

Spring Boot Actuator 模块提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP 跟踪等，帮助我们监控和管理 Spring Boot 应用。这个模块是一个采集应用内部信息暴露给外部的模块，上述的功能都可以通过 HTTP 和 JMX 访问。

因为暴露内部信息的特性，Actuator 也可以和一些外部的应用监控系统整合（Prometheus, Graphite，DataDog，Influx，Wavefront，New Relic 等）。这些监控系统提供了出色的仪表板，图形，分析和警报，可帮助你通过一个统一友好的界面，监视和管理你的应用程序。

Actuator 使用 Micrometer 与这些外部应用程序监视系统集成。这样一来，只需很少的配置即可轻松集成外部的监控系统。

## 1.16. Spring Boot 如何做请求参数校验？

JSR 提供的校验注解:

@Null 被注释的元素必须为 null
@NotNull 被注释的元素必须不为 null
@AssertTrue 被注释的元素必须为 true
@AssertFalse 被注释的元素必须为 false
@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@Size(max=, min=) 被注释的元素的大小必须在指定的范围内
@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内
@Past 被注释的元素必须是一个过去的日期
@Future 被注释的元素必须是一个将来的日期
@Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式

## 1.17. 如何使用 Spring Boot 实现全局异常处理？

## 1.18. Spring Boot 中如何实现定时任务 ?
Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。

ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。

Spring Task：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。

```java
@Scheduled(fixedDelay = 1000)
public void scheduleFixedDelayTask() {
    System.out.println(
      "Fixed delay task - " + System.currentTimeMillis() / 1000);
}
```


Quartz：这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。
